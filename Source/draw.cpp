#include <thread>
#include <errno.h>
#include "../Header/draw.h"


/****************物体を指定した個数だけランダムに追加する*******************************************************************************************************************/
    void randputsphere(int number_of_sphere, double radius_min, double radius_max, Objects& objects, double radius, L::sharePattern ppattern_l, M::sharePattern ppattern)//球同士が接触しないようにランダムに設置する
    {
        //球が敷きつまりすぎると球が置けなくなってループが終わらなくなってしまう可能性があることに注意せよ
        
        /****************************************変数定義***********************************************************************/
        Vec3 v;
        double nextradius;//設置する物体の半径(乱数)
        int counter;//重なる球の個数を数える;
        int number_of_sphere0 = objects.objectnumber[(int)SHAPES::SPHERE];//この処理を実行する前にすでに設置されている球の個数を保存する
        double theta, phi, alpha;
        int& spherenum = objects.objectnumber[(int)SHAPES::SPHERE];//変数名が長いので簡単になるように表す 球を置くにつれて増加する
        /*********************************************************************************************************************/
        std::cout << "▼球のランダムな設置を開始▼" << std::endl;
        while((spherenum - number_of_sphere0) < number_of_sphere)//randputsphereのなかで設置した球の個数(spherenum - number_of_sphere0)が指定された数(number_of_sphere)に等しくなるまでループする
        {
            counter = 0;//初期化

            /*********************************球の半径, 位置をランダムに決める***********************************/
            v = Vec3((rnd()-0.5)*180, (rnd()-0.5)*180, (rnd()-0.5)*180);//ランダムに球の位置を決める
            nextradius = rnd() * (radius_max - radius_min) + radius_min;//ランダムに球の半径を決める  //radius_minからradius_maxまで確率が一様
            /**********************************************************************************************/

            /*******************************その球がすでに置かれている球と重ならないか調べる**********************************/
            for(int l = 0; l< objects.objectnumber[(int)SHAPES::SPHERE]; l++)//すでにある球のすべてを調べる
            {
                Sphere* ps;//キャスト用のポインタ
                ps = dynamic_cast<Sphere*> ((objects.shapes[(int)SHAPES::SPHERE])[l].get());
                if(((ps->Center)-v).length()<(radius + nextradius))//すでにある球と新しい球が重なるなら
                counter++;//重なる球の個数を1増やす
            }
            /**********************************************************************************************************/

            /*********************球の設置***************************************/
            if(counter == 0)//もし重なる球がないなら
            {
                theta =     M_PI * rnd();
                phi   = 2 * M_PI * rnd();
                alpha = 2 * M_PI * rnd();
                objects.addshape(std::make_shared<Sphere>(Sphere(radius, theta, phi, alpha, v, ppattern_l, ppattern)));//球を追加  ついでにtheta, phi, alphaをランダムに決める
            }  
            
            /******************************************************************/
        }
        std::cout << "▲球のランダムな設置を終了▲" << std::endl;
    }

    void randputpipe(Objects& objects, int number_of_pipe, L::sharePattern ppattern_l, M::sharePattern ppattern)//
    {
        Vec3 v1, v2;
        for(int i = 0; i < number_of_pipe ; i++)
        {
            

            v1 = Vec3((rnd()-0.5)*10000, (rnd()-0.5)*10000, (rnd()-0.5)*10000);//ランダムに位置を決める
            v2 = Vec3((rnd()-0.5)*10000, (rnd()-0.5)*10000, (rnd()-0.5)*10000);
            
            objects.addshape(std::make_shared<Pipe>(Pipe(20, v1, v2-v1, 0, ppattern_l, ppattern)));//円柱を追加
                    
    
                    
        }

    }
/*********************************************************************************************************************************************************************/


void draw(int const& i, Image& image, Camera const& camera, Sky const& sky, Objects const& objects, bool const& auto_)//画像を描画する
{

    /***********************表示***************************************************************/
        std::cout << "auto_の値は"<< auto_ << std::endl;//表示
        std::cout << "縦は" << image.height << ", 横は" << image.width << "\n";//表示

        int sample_auto; //これらはオートのときのみ用いられる
        double auto_c;   //

        if(auto_ == 1)
        {
            sample_auto = 1;
            auto_c = 2.5;

            std::cout << "オートサンプル数は" << sample_auto << std::endl;
            std::cout << "オートの明るさ倍数は" << auto_c << std::endl;
        }

    /*****************************************************************************************/
    image.sample_sum = 0;//サンプリング済みの数を0にリセットする(まだサンプルを1つもとっていないため)

    while(1)//サンプルをとって画像として出力する処理を繰り返す
    {
        std::cout << "\033[5;34m--------------------------------------------------------\033[m" << std::endl;

        double b_;//次へ進むか進まないか戻るかなどを判定するのに用いる
        double c_;//画像データを何倍するか計算するのに用いる
        double sample_;//サンプル数をセットするために用いられる

        /***********画像何枚分に相当するサンプルを取るのか決め, さらに個々のサンプル数を決める************************************************/
        if(auto_ == 0)
        {
            /******************何枚分取るか決める*********************************/
                do
                {
                    input("画像何枚分のサンプルを取るか(1以上の整数)を入力せよ", sample_);

                }while(sample_ < 1);//1より小さい場合は不適切だから

                image.num_of_samples = (int)sample_;//サンプル数を設定

                std::cout << "これから" << image.num_of_samples << "枚に相当するサンプルを取る" << std::endl;
            /******************************************************************/

            /******************個々のサンプル数を決める***********************************************/
            {
                bool abc;//個々の分散に比例させてサンプルを取るか取らないかのフラグ

                if(image.sample_sum >= 2)//サンプルが2枚以上取られている場合は分散が求まるのでその後の選択ができる
                {
                    input("個々の分散に比例させてサンプルを取る場合は0以外, そうでない場合は0を入力せよ", b_);

                    if(b_ != 0)//サンプルを個々の分散に比例させると希望した場合
                    {   
                        abc = 1;//個々の分散に比例するように各々のサンプル数を設定するようにフラグをセットする
                    }
                    else//サンプルを一様に取ると希望した場合
                    {
                        abc = 0;//サンプルを一様に取るようにフラグをセットする
                    }
                }
                else//サンプル数が0, 1枚分の場合は分散が求まらないので必ずサンプルを一様に取る
                {
                    abc = 0;//最初は必ずサンプルを一様に取るようにフラグをセットする
                }

                image.setNumber_of_samples_each(abc);//フラグが1ならこれから取る(個々の画素のサンプル数)が(これまでに取った個々の画素のサンプルから求められた個々の分散)に比例するように設定する     0ならこれから取る(個々の画素のサンプル数)を一様になるように設定する(全ての画素のサンプル数をsample_にする)
                //(個々の分散に比例するように設定する場合, num_of_samplesがsample_から微妙にずれる可能性がある)
            }
            /************************************************************************************/
        }
        else
        {
            image.num_of_samples = sample_auto;
            image.setNumber_of_samples_each(0);
        }
        
        /**************************************************************************************************************************/


        image.GettingReady();//秒数のカウンター, 1ループ中での取り終わりサンプルカウンターを0にリセットする

        /**************************並列処理の開始***************************************************/
            std::thread threads[threadsum];//サンプルの取得用のthreadの配列(空の配列)

            std::thread   a([&image] () {image.timecounter(); });//時間の計測の開始
            std::thread   b([&image] () {image.printpercent();});//残り時間などの表示を開始する

            for(int n = 0; n < threadsum; n++)//サンプルの取得の開始
            {
                (threads[n]) = std::move(std::thread([&image, &camera, &objects, &sky, n](){image.addSample(camera, objects, sky, n);}));
            }
        /*****************************************************************************************/

        /************並列処理で確保されたメモリーの解放(処理が終わったら上から順番に開放される)****************/
            a.join();
            b.join();

            for(int n = 0; n < threadsum; n++)
            {
                threads[n].join();
            }
        /******************************************************************************************/

        /***********************サンプルを取った後で画像を定数倍して出力したり, サンプルの標準偏差を描画したりしてその後でさらにサンプルを取るか取らないかを決めたりできる***************************/


            double sumlast = image.sample_sum;//前回までのサンプル数は画像何枚分に相当するか

            double sam =  image.num_of_samples_pixels/(double)(image.width * image.height);//今回のサンプル数は画像何枚分に相当するか

            image.sample_sum += sam;//今回までのサンプル数は画像何枚分に相当するか

            //これまでに取ったサンプル数はサンプリングと同時に加算された
            

            std::cout  <<"前回までのサンプル数の合計は画像" << sumlast << "枚分に相当し, 今回のサンプル数は" << sam << "枚分に相当し, 今回までのサンプル数の合計は" << image.sample_sum << "枚分に相当する" << std::endl;


            
            if(auto_)/////////////////////////auto_が1なら//////////////////////
            {                               //自動的に全ての画素が均等にサンプリングされる

                image.CalculateColor(auto_c);
                image.Output_To_Ppm(i);//ファイルとして書き出す
                break;//終了(もうサンプルを取らない)
            }


            ///////////////////////////////auto_が0なら//////////////////////////////////////////////

            input("SDを確認するなら0以外, しないで画像の出力に進むなら0を入力せよ", b_);
        
            if(b_ == 0)
            {
                goto fin;//画像の出力に進む
            }


            if(image.sample_sum == 1)//サンプル数が2より小さい場合
            {
                std::cout << "サンプル数が1の場合はSDは求められない" << std::endl;
                goto fin;//画像の出力に進む
            }

            p1:
        
            input("平均値のSDデータを何倍するかの値を入力せよ(SDが255以下になるように)", c_);


            image.CalculateSD_average(c_);//平均値のSDデータについて表示する


            input("もう一度確認するなら0以外を, 次へ進む場合は0を入力せよ", b_);


            if(b_ != 0)
            {
                goto p1;
            }
                
        
            input("平均値のSDデータを書き込むなら0以外を, 個々のSDデータの確認に進む場合は0を入力せよ", b_);

            
            if(b_ != 0)
            {
                image.OutputSD_To_Ppm(i);//ファイルとして書き出す
            }


            p2:
            

            input("個々のSDデータを何倍するかの値を入力せよ(SDが255以下になるように)", c_);

            image.CalculateSD_each1(c_);//平均値のSDデータについて表示する



            input("もう一度確認するなら0以外を, 次へ進む場合は0を入力せよ", b_);


            if(b_ != 0)
            {
                goto p2;
            }
                
        
            input("個々のSDデータを書き込むなら0以外を, 書き込まずに画像を出力する場合は0を入力せよ", b_);

            
            if(b_ == 0)
            {
                goto fin;//画像の出力に進む
            }


            image.OutputSD_To_Ppm(i);//ファイルとして書き出す




            input("画像の出力へ進むには0を,戻るには0以外を入力せよ", b_);


            if(b_ != 0)
            {
                goto p1;//平均値のSDの確認に戻る
            }


            fin:


            input("画像データを何倍するかの値を入力せよ", c_);


            image.CalculateColor(c_);
        

            input("戻るなら0以外を, 画像を出力する場合は0を入力せよ", b_);


            if(b_ != 0)
            {
                goto fin;
            }

            image.Output_To_Ppm(i);//ファイルとして書き出す


            input("255以上の値を確認する場合は0以外を、次へ進む場合は0を入力せよ", b_);


            if(b_ != 0)
            {
                image.Output_Over255_To_Ppm(i);//画素のうちrgbが255以上の成分をもつ点が白色として出力される
            }


            input("画像の出力をやり直す場合は0以外を, 終わる場合は0を入力せよ", b_);


            if(b_ != 0)
            {
                goto fin;//画像の出力に戻る
            }


            std::cout << image.sample_sum << "回サンプル取得済みだが,";

            input("サンプルを更に取る場合は0以外を、終了する場合は0を入力せよ", b_);


            if(b_ == 0)
            {
                break;//終了(もうサンプルを取らない)
            }

            //サンプルを更に取る場合
            continue;//もう一度サンプルを取る
            
        /*********************************************************************************************************************************************************************/
    }
}